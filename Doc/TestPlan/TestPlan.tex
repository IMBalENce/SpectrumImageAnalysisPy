\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{tabularx}
\usepackage{xr-hyper}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\externaldocument{../SRS/SRS}

\newcommand{\progname}{SpectrumImageAnalysisPy}
\newcommand{\rthereqnum}{P\thereqnum}
\newcommand{\ddref}[1]{DD\ref{#1}}

\input{../Comments}

\begin{document}
\bibliographystyle{ieeetr}
\title{SpectrumImageAnalysisPy} 
\author{Isobel Bicket}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{4cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
\today & 1.0 & Initial draft\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  RMS & Root Mean Square\\
  T & Test\\
  \bottomrule
\end{tabular}\\

See the SRS document \hyperref[TableSymbols]{Table of Symbols} and \hyperref[TableUnits]{Table of Units} for further definitions. 

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

This document outlines the different tests and assessment tools which will be used for assessing the performance of \progname{}. The testing will be done to build confidence in the performance of the program and allow the end user to use it with more assurity that it is behaving correctly and any artifacts seen in the data are either a known result of the program, or independent of the use of \progname{} to process the data.

\section{General Information}
The testing outlined in this document gives valuable contributions to the level of trust in the performance of the software. Not only will testing the software build confidence that it is performing correctly, but the results of the tests will also tell the user what to expect when running the software, for instance in terms of performance milestones. Testing not only ensures that the software will, within predictive power, fulfill its \hyperref[subsec:FR]{functional requirements}, but gives the progress and effectiveness of the software in fulfulling the \hyperref[subsec:NfR]{non-functional requirements}.

\subsection{Purpose}
The purpose of this document is to describe the tests which will be carried out on \progname{} to verify that it meets the requirements described in the \hyperref[doc:SRS]{SRS}.

\subsection{Scope}
This document will cover the verification plan for testing the software \progname{}, including the system tests towards verifying that the software meets the functional and non-functional requirements; and the unit tests, of which a non-exhaustive list is given. The document does not cover the validation of the software algorithms. 

\subsection{Overview of Document}
 It begins by outlining the structure of the document, followed by an overview of the testing arrangements. Specific details follow on the tests which will be performed to test whether or not \progname{} satisfies the \hyperref[subsec:FuncReqTest]{functional} and \hyperref[subsec:NonfuncReqTest]{non-functional} requirements, as well as details of the unit tests which will be written. The unit tests themselves may satisfy some of the functional requirements without needing system testing, these will be detailed under \hyperref[sec:UnitTest]{Unit Testing Plan} as appropriate.

\section{Plan}
This section details the plan to be followed when testing the software, including those involved in the testing, the testing approach, and the verification tools which will be used.
	
\subsection{Software Description}
The software, \progname{}, is designed as a data analysis tool for electron energy loss spectroscopy and cathodoluminescence spectrum imaging data. It provides several data processing routines to the user and a graphical user interface to navigate the 3D data set and export desired spectra or image slices. The requirements and expectations for \progname{} are detailed in the \hyperref[doc:SRS]{Software Requirements Specification}.

\subsection{Test Team}
The test team has one member: Isobel Bicket.

\subsection{Automated Testing Approach}

Unit testing will be performed on the functions within the code, as an automated task to be done with every update of the code. The running of automated tests also provides regression testing and integration testing of new features and updates. The goal of testing is 100\% code coverage.\\
The testing plan will not cover testing of the GUI, only the functions called by the GUI after user interaction. Proper user interfacing is expected to be done by the library used to build the GUI.\\

\subsection{Verification Tools}

The following verification tools will be used
\begin{itemize}
	\item Python unittest library: for performing unit tests on the code;
	\item Python coverage library: to determine the coverage of the tests;
	\item Deconvo.m: a Richardson-Lucy deconvolution algorithm implementation in Matlab, written by Dr. E.P. Bellido \cite{bellido_toward_2014};
	\item Python HyperSpy library: a Python-based library for spectrum processing for EELS and other techniques \cite{francisco_de_la_pena_2017_583693}.
\end{itemize}

\subsection{Non-Testing Based Verification}

The following non-testing based verification methods will be used to assess the performance of \progname{}

\begin{itemize}
	\item Code review: a detailed code review will be performed by an external party and feedback provided;
	\item User survey: a group of qualified users will be asked to process a sample dataset using the software and will be polled on their user experience.
\end{itemize}

\section{System Test Description}
\label{sec:SysTest}
This section lists the system tests to be performed to verify whether or not the program fulfills the functional requirements and to test how well it meets the non-functional requirements. Note that some of the tests for the functional requirements are unit tests and can be found in the \hyperref[sec:UnitTest]{Unit Test} section.

\subsection{Tests for Functional Requirements}
\label{subsec:FuncReqTest}
Here the tests to verify whether or not \progname{} meets the functional requirements are listed. In addition, some of the tests validate the algorithms chosen for use in \progname{}.

\subsubsection{Deconvolution}
In this subsection, the tests for the performance of the Richardson-Lucy deconvolution algorithm will be explained.
\paragraph{}

\begin{enumerate}

\item{Deconvolution error estimation - blank PSF}
\label{TFR:RLblankPSF}

Type: Functional, Dynamic
					
Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum (for instance, the data used in the paper by Bellido \textit{et al} \cite{bellido_toward_2014}, if it is available from the author). Otherwise a spectrum will be simulated. A range of integers will be used as input for the number of deconvolution iterations. The input of a point spread function to the deconvolution will be an array of ones.

Output: A series of spectra deconvolved using the range of iterations given in the input, and a plot of the RMS error vs the number of iterations used.
					
How test will be performed: A series of deconvolutions will be run on the artificial spectrum, with varying numbers of iterations to produce a set of deconvolved spectra. The difference between the deconvolved spectra and the original simulated spectrum will be calculated and the RMS error plotted as a function of number of iterations. Ideally the deconvolved spectra will be identical to the input spectrum, because we are using a null function as the PSF reference.\\


\item{Deconvolution error estimation}
\label{TFR:RLerror}

Type: Functional, Dynamic
					
Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum convolved with a broadening function (for instance, the data used in the paper by Bellido \textit{et al} \cite{bellido_toward_2014}, if it is available from the author). Otherwise a spectrum will be simulated and convolved with a broadening function (such as a Lorentzian peak, a Gaussian peak, or an experimental point spread function). A range of integers will be used as input for the number of deconvolution iterations. The broadening function itself is also an input to the deconvolution.

Output: A series of spectra deconvolved using the range of iterations given in the input, and a plot of the RMS error vs the number of iterations used.
					
How test will be performed: A series of deconvolutions will be run on the artificially broadened spectrum, using the broadening function as the point spread function, with varying numbers of iterations to produce a set of deconvolved spectra. The difference between the deconvolved spectra and the original simulated spectrum (before convolution with a broadening function) will be calculated and the root mean square error plotted as a function of number of iterations.\\


\item{Deconvolution signal-to-noise ratio estimation}
\label{TFR:RLSNR}
Type: Functional, Dynamic
					
Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum convolved with a broadening function (for instance, the data used in the paper by Bellido \textit{et al} \cite{bellido_toward_2014}, if it is available from the author). Otherwise a spectrum will be simulated and convolved with a broadening function (such as a Lorentzian peak, a Gaussian peak, or an experimental point spread function). A range of integers will be used as input for the number of deconvolution iterations. The broadening function itself is also an input to the deconvolution.

Output: A series of spectra deconvolved using the range of iterations given in the input, and a plot of the SNR vs the number of iterations used.
					
How test will be performed: A series of deconvolutions will be run on the artificially broadened spectrum, using the broadening function as the point spread function, with varying numbers of iterations to produce a set of deconvolved spectra. The difference between the deconvolved spectra and the original simulated spectrum (before convolution with a broadening function) will be calculated and the signal-to-noise ratio plotted as a function of number of iterations. The test will follow the SNR estimation used in \cite{bellido_toward_2014}, taking the variance of the signal every five data points.\\

\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}
\label{subsec:NonfuncReqTest}

\subsubsection{Program speed}

\begin{enumerate}

\paragraph{Deconvolution}
\item{Deconvolution calculation time - SI size}

Type: Performance, Dynamic
					
Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum convolved with a broadening function (for instance, the data used in the paper by Bellido \textit{et al} \cite{bellido_toward_2014}, if it is available from the author), and transformed into a spectrum image data format (of 3D shape). Otherwise a spectrum will be simulated and convolved with a broadening function (such as a Lorentzian peak, a Gaussian peak, or an experimental point spread function). The broadening function itself is also an input to the deconvolution. The spectrum image size will be varied from $(1\text{ by }1\text{ by }K)$ to $(1000 \text{ by } 1000 \text{ by } K)$ with a minimum of 10 intermediate values. 25 iterations will be performed for each spectrum image size. A typical value for $K$ might be 2048 or 1024, depending on the dataset used.

Output: A plot of the calculation time required vs the size of the spectrum image used.

How test will be performed: The Richardson-Lucy deconvolution algorithm will be run on a series of spectrum images of varying size. 25 iterations will be run on each spectrum image and the time required to finish the calculations recorded and plotted against the number of $(x, y)$ pixels in the spectrum image.\\


\item{Deconvolution calculation time - iterations}

Type: Performance, Dynamic
					
Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum convolved with a broadening function (for instance, the data used in the paper by Bellido \textit{et al} \cite{bellido_toward_2014}, if it is available from the author), and transformed into a spectrum image data format (of 3D shape). Otherwise a spectrum will be simulated and convolved with a broadening function (such as a Lorentzian peak, a Gaussian peak, or an experimental point spread function). The broadening function itself is also an input to the deconvolution. The spectrum image size will be set at $(500 \text{ by } 500 \text{ by } E)$ and a the number of iterations will be changed from 1 to 500 with at least 10 intermediate steps. A typical value for E might be 2048 or 1024, depending on the dataset used.

Output: A plot of the calculation time required vs the number of iterations used.

How test will be performed: The Richardson-Lucy deconvolution algorithm will be run repeatedly on a spectrum image with varying numbers of iterations. The time required to finish the calculations will be recorded and plotted against the number of $(x, y)$ pixels in the spectrum image.\\

\paragraph{Normalization}
\item{Normalization calculation time}

Type: Performance, Dynamic

Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum (for instance, an artificially created spectrum, a range of values from 0 to the number of pixels used in the spectrum image), transformed into a spectrum image data format (of 3D shape).The spectrum image size will be varied from $(1\text{ by }1\text{ by }K)$ to $(1000 \text{ by } 1000 \text{ by }K)$ with a minimum of 10 intermediate values. A typical value for $K$ might be 2048 or 1024, depending on the dataset used.

Output: A plot of the calculation time required vs the size of the spectrum image used.

How test will be performed: The normalization algorithm will be run on a series of spectrum images of varying size, normalizing to the integral of the full spectrum. The time required to finish the calculations will be recorded and plotted against the number of $(x, y)$ pixels in the spectrum image.\\

\paragraph{Gain Correction}
\item{Gain correction calculation time}

Type: Performance, Dynamic

Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum (for instance, an artificially created spectrum, a range of values from 0 to the number of pixels used in the spectrum image), transformed into a spectrum image data format (of 3D shape).The spectrum image size will be varied from $(1\text{ by }1\text{ by }K)$ to $(1000 \text{ by } 1000 \text{ by }K)$ with a minimum of 10 intermediate values. A typical value for $K$ might be 2048 or 1024, depending on the dataset used. The gain correction factor will be given as a range of integers from 0 to $K-1$.

Output: A plot of the calculation time required vs the size of the spectrum image used.

How test will be performed: The gain correction function will be run on a series of spectrum images of varying size. The time required to finish the calculations will be recorded and plotted against the number of $(x, y)$ pixels in the spectrum image.\\

\paragraph{Background subtraction}
\item{Background subtraction calculation time}

Type: Performance, Dynamic

Initial State: Spectrum loaded into \progname{}.

Input: A known spectrum (for instance, the data used in the paper by Bellido \textit{et al} \cite{bellido_toward_2014}, if it is available from the author), transformed into a spectrum image data format (of 3D shape).The spectrum image size will be varied from $(1\text{ by }1\text{ by }K)$ to $(1000 \text{ by } 1000 \text{ by }K)$ with a minimum of 10 intermediate values. A typical value for $K$ might be 2048 or 1024, depending on the dataset used. The background correction will be given as a an array of ones of size $K$.

Output: A plot of the calculation time required vs the size of the spectrum image used.

How test will be performed: The gain correction function will be run on a series of spectrum images of varying size. The time required to finish the calculations will be recorded and plotted against the number of $(x, y)$ pixels in the spectrum image.\\ 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\subsection{Traceability Between Test Cases and Requirements}

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline 
		& \hyperref[TFR:RLblankPSF]{1} & \hyperref[TFR:RLerror]{2} & \hyperref[TFR:RLSNR]{3} & & \hyperref[sec:UnitTest]{Unit Test} \\
		\hline
		\hyperref[R_SI_inputs]{SI input}     			&  &  &  &  & X \\ 
		\hline
		\hyperref[R_spectrum_inputs]{Spectrum input}    &  &  &  &  & X \\ 
		\hline
		\hyperref[R_Input_dimension]{Input dimensions}  &  &  &  &  & X \\
		\hline
		\hyperref[R_Input_dimension]{SI slicing}		&  &  &  &  & X \\ 
		\hline
		\hyperref[R_SI_area]{SI area}          			&  &  &  &  & X \\ 
		\hline
		\hyperref[R_deconvolution]{Deconvolution}       & X & X & X &  & X \\ 
		\hline
		\hyperref[R_normalization]{Normalization} 		&  &  &  &  &  \\ 
		\hline
		\hyperref[R_normalization]{Background} 			&  &  &  &  &  \\ 
		\hline
		\hyperref[R_normalization]{Gain}  				&  &  &  &  &  \\ 
		\hline
	\end{tabular}
	\caption{Traceability Matrix Showing the Connections Between Test Cases and
Requirements}
	\label{Table:A_trace}
\end{table}

				
\section{Unit Testing Plan}
\label{sec:UnitTest}

\subsection{Inputs}
		
\paragraph{Spectrum Image Input}

\begin{enumerate}

\item{SI Data array with energy range (EELS)}

Type: Functional, Dynamic, Unit

Initial State: None

Input: 3D data array, present in memory; use standard calibration variabilities\\
For example, the following values might be used to create an SI: 
\begin{itemize}
	\item $x = [0, 1]$
	\item $y = [0, 1]$
	\item $\text{Intensity} = \text{ones}(\text{size}(2,2,10))$
	\item $\text{x calibration} = 1\ \si{\nano\metre}/\text{pixel}$
	\item $\text{energy range} = \text{range}(0, 10)\ \si{\electronvolt}$
\end{itemize}

Output: Spectrum Image stored within \progname{}; the first and second axes should correspond to spatial dimensions, while the third axis should correspond to a spectral dimension.

How test will be performed: Create a 3D data array and attempt to initialize a spectrum image in \progname{}. No errors should be raised. The spectrum image axes should be read in the correct order (x, y, E), and the calibrations should be applied to the correct axes. Addresses \hyperref[R_SI_inputs]{Functional Requirement}.


\item{SI Data array with dispersion (EELS)}

Type: Functional, Dynamic, Unit

Initial State: None

Input: 3D data array, present in memory; use standard calibration variabilities\\
For example, the following values might be used to create an SI: 
\begin{itemize}
	\item $x = [0, 1]$
	\item $y = [0, 1]$
	\item $\text{Intensity} = \text{ones}(\text{size}(2,2,10))$
	\item $\text{x calibration} = 1\ \si{\nano\metre}/\text{pixel}$
	\item $\text{dispersion} = 0.01\ \si{\electronvolt}/\text{pixel}$
	\item $E(0) = -2\ \si{\electronvolt}$
\end{itemize}

Output: Spectrum Image stored within \progname{}; the first and second axes should correspond to spatial dimensions, while the third axis should correspond to a spectral dimension.

How test will be performed: Create a 3D data array and attempt to initialize a spectrum image in \progname{}. No errors should be raised. The spectrum image axes should be read in the correct order (x, y, E), and the calibrations should be applied to the correct axes.


\item{SI Data array with wavelength range (CL)}

Type: Functional, Dynamic, Unit

Initial State: None

Input: 3D data array, present in memory; use standard calibration variabilities\\
For example, the following values might be used to create an SI: 
\begin{itemize}
	\item $x = [0, 1]$
	\item $y = [0, 1]$
	\item $\text{Intensity} = \text{ones}(\text{size}(2,2,10))$
	\item $\text{x calibration} = 1\ \si{\nano\metre}/\text{pixel}$
	\item $\text{wavelength range} = \text{range}(0, 10)\ \si{\nano\metre}$
\end{itemize}

Output: Spectrum Image stored within \progname{}; the first and second axes should correspond to spatial dimensions, while the third axis should correspond to a spectral dimension.

How test will be performed: Create a 3D data array and attempt to initialize a spectrum image in \progname{}. No errors should be raised. The spectrum image axes should be read in the correct order (x, y, E), and the calibrations should be applied to the correct axes.


\item{SI .dm3 file}

Type: Functional, Dynamic, Unit

Initial State: None

Input: A .dm3 file, containing a fabricated spectrum image. The .dm3 file will be created using Digital Micrograph (Gatan Microscopy Suite Software) software \cite{noauthor_gatan_nodate} with the following parameters:
\begin{itemize}
	\item $x = [0, 1]$
	\item $y = [0, 1]$
	\item $\text{Intensity} = \text{ones}(\text{size}(2,2,10))$
	\item $\text{x calibration} = 1\ \si{\nano\metre}/\text{pixel}$
	\item $\text{dispersion} = 0.01\ \si{\electronvolt}/\text{pixel}$
	\item $E(0) = -2\ \si{\electronvolt}$
\end{itemize}

Output: EELS Spectrum Image stored within \progname{}, with metadata assigned to appropriate values

How test will be performed: Read in the .dm3 file with \progname{}. Check that no errors are raised. Display the spectrum image to manually check that the data was read in correctly. Check spatial and spectral calibration to verify metadata was assigned correctly.

\an{There is a potential problem with the .dm3 file, since there are many version of Digital Micrograph out there and many different set-ups, all of which may format their .dm3 slightly differently. Not sure on the best way to test this, without asking several other labs for pieces of data (which are not usually shared readily) and trying out all of them.}

\item{SI .h5 file}

Type: Functional, Dynamic, Unit.

Initial State: None

Input: .h5 file, containing an acquired or fabricated spectrum image. The .h5 spectrum image file originates from Odemis software \cite{bv_odemis:_nodate}, it may be possible to fabricate a spectrum image using the scripting interface, using the following values for the calibration parameters, otherwise it may be necessary to use an acquired data file.

\begin{itemize}
	\item $x = [0, 1]$
	\item $y = [0, 1]$
	\item $\text{Intensity} = \text{ones}(\text{size}(2,2,10))$
	\item $\text{x calibration} = 1\ \si{\nano\metre}/\text{pixel}$
	\item $\text{wavelength range} = \text{range}(0, 10)\ \si{\nano\metre}$
\end{itemize}

Output: CL Spectrum Image stored within \progname, with metadata assigned to appropriate values.
					
How test will be performed: Read in the .h5 file with \progname{}. Check that no errors are raised. Check spatial and spectral calibration to verify metadata was assigned correctly.

\item{SI Data array with dispersion (EELS) - complex numbers}

Type: Functional, Dynamic, Unit

Initial State: None

Input: 3D data array, present in memory; use standard calibration variabilities\\
For example, the following values might be used to create an SI: 
\begin{itemize}
	\item $x = [0, 1]$
	\item $y = [0, 1]$
	\item $\text{Intensity} = \text{ones}(\text{size}(2,2,10)) + j * \text{ones}(\text{size}(2,2,10))$
	\item $\text{x calibration} = 1\ \si{\nano\metre}/\text{pixel}$
	\item $\text{dispersion} = 0.01\ \si{\electronvolt}/\text{pixel}$
	\item $E(0) = -2\ \si{\electronvolt}$
\end{itemize}

Output: Spectrum Image stored within \progname{}; the first and second axes should correspond to spatial dimensions, while the third axis should correspond to a spectral dimension.

How test will be performed: Create a 3D data array and attempt to initialize a spectrum image in \progname{}. No errors should be raised. The spectrum image axes should be read in the correct order (x, y, E), and the calibrations should be applied to the correct axes.

\end{enumerate}

\paragraph{Spectrum Input}

\begin{enumerate}

\item{Spectrum Data array}

Type: Functional, Dynamic, Unit.
					
Initial State: 
					
Input: 1D data array, present in memory. For example, the following data may be used to initialize a Spectrum:
\begin{itemize}
	\item $\text{intensity} = \text{ones}(\text{size}(10))\ \text{counts}$
	\item $\text{energy range} = \text{range}(0, 10)\ \si{\electronvolt}$
\end{itemize}

Output: Spectrum stored within \progname{}, with data assigned to appropriate values.
					
How test will be performed: Create a 1D data array and attempt to read it with \progname{}. No errors should be raised. The unit test will check that the intensity and energy range are assigned to the appropriate variables, as well as the spectral calibration.


\item{Spectrum .csv file}

Type: Functional, Dynamic, Unit.

Initial State: 

Input: .csv file, containing a 1D spectrum. The following data may be used to create a spectrum csv file:
\begin{itemize}
	\item $\text{Intensity} = \text{ones}(\text{size}(10))\ \text{counts}$
	\item $\text{energy range} = \text{range}(0, 10)\ \si{\electronvolt}$
\end{itemize}

Output: Spectrum stored within \progname{}, with data assigned to appropriate values

How test will be performed: A csv file containing 1D spectrum data will be imported. No errors should be raised. The unit test will check that the intensity and energy range are assigned to the appropriate variables, as well as the spectral calibration.


\item{Spectrum Data array - complex numbers}

Type: Functional, Dynamic, Unit.

Initial State: 

Input: 1D data array, present in memory. For example, the following data may be used to initialize a Spectrum:
\begin{itemize}
	\item $\text{energy values} = \text{ones}(\text{size}(10)) + j*\text{ones}(\text{size}(10))\ \text{counts}$
	\item $\text{energy range} = \text{range}(0, 10)\ \si{\electronvolt}$
\end{itemize}

Output: Error message - input must be real

How test will be performed: Create a 1D data array and attempt to read it with \progname{}. An error should be raised.


\item{Spectrum Data array - 2D array}

Type: Functional, Dynamic, Unit.

Initial State: 

Input: 2D data array, present in memory. For example, the following data may be used to initialize a Spectrum:
\begin{itemize}
	\item $\text{energy values} = \text{ones}(\text{size}(2, 2))\ \text{counts}$
	\item $\text{energy range} = \text{range}(0, 2)\ \si{\electronvolt}$
\end{itemize}

Output: Error message - input must be 1D

How test will be performed: Create a 1D data array and attempt to read it with \progname{}. An error should be raised.

\end{enumerate}

\paragraph{Energy range slicing}

The spectrum image to be used for these tests will be the same for all tests in this section and may, for example, consist of float values from 0 to 1, reshaped into the size (2,2,10), with an energy range from $0-9 \si{\electronvolt}$.

\begin{enumerate}

\item{Extract $(x,y)$ slice from spectrum}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: Two values within the spectrum range calibration values. For example, in a spectrum image with an energy range from $0-9\ \si{\electronvolt}$, the input values might be 5 and 7. the existing spectrum image must have different values of intensity at each pixel and each channel along the energy axis.

Output: An $(x,y)$ image averaged over the spectral range specified by the input to the test.

How test will be performed: Using a 3D dataset, such as those used in the Spectrum image 3D dataset unit test, the test will request the return value of an $(x,y)$ image averaged over the chosen spectral range. No errors should be raised. Check that the range averaged over is the same as the range selected.


\item{Extract $(x,y)$ slice from spectrum, slice less than any value in the energy range}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: Two values within the spectrum range calibration values. For example, in a spectrum image with an energy range from $0-9\ \si{\electronvolt}$, the input values might be -2 and 5. the existing spectrum image must have different values of intensity at each pixel and each channel along the energy axis.

Output: An $(x,y)$ image averaged over the spectral range specified by the input to the test and the minimum value of the energy range in the spectrum image.

How test will be performed: Using a 3D dataset, such as those used in the Spectrum image 3D dataset unit test, the test will request the return value of an $(x,y)$ image averaged over the chosen spectral range. No errors should be raised. Check that the range averaged over is the same as the range selected within the data limits.


\item{Extract $(x,y)$ slice from spectrum, slice more than any value in the energy range}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: Two values within the spectrum range calibration values. For example, in a spectrum image with an energy range from $0-9\ \si{\electronvolt}$, the input values might be 5 and 12. the existing spectrum image must have different values of intensity at each pixel and each channel along the energy axis.

Output: An $(x,y)$ image averaged over the spectral range specified by the input to the test and the maximum value of the energy range in the spectrum image.

How test will be performed: Using a 3D dataset, such as those used in the Spectrum image 3D dataset unit test, the test will request the return value of an $(x,y)$ image averaged over the chosen spectral range. No errors should be raised. Check that the range averaged over is the same as the range selected within the data limits.


\item{Extract $(x,y)$ slice from spectrum, slice completely outside the energy range}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: Two values within the spectrum range calibration values. For example, in a spectrum image with an energy range from $0-9\ \si{\electronvolt}$, the input values might be -5 and -2. the existing spectrum image must have different values of intensity at each pixel and each channel along the energy axis.

Output: A warning should be raised that the range selected is outside the range for which there is data available.

How test will be performed: Using a 3D dataset, such as those used in the Spectrum image 3D dataset unit test, the test will request the return value of an $(x,y)$ image averaged over the chosen spectral range. A warning should be raised and no image returned.


\item{Extract $(x,y)$ slice from spectrum, backwards slice}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: Two values within the spectrum range calibration values. For example, in a spectrum image with an energy range from $0-9\ \si{\electronvolt}$, the input values might be 7 and 5. the existing spectrum image must have different values of intensity at each pixel and each channel along the energy axis.

Output: An $(x,y)$ image averaged over the spectral range specified by the input to the test.

How test will be performed: Using a 3D dataset, such as those used in the Spectrum image 3D dataset unit test, the test will request the return value of an $(x,y)$ image averaged over the chosen spectral range (regardless of the order of selection, the program should behave exactly the same as if the input range was 5 to 7). No errors should be raised. Check that the range averaged over is the same as the range selected (ie, by knowing what data the spectrum image contains).

\end{enumerate}

\paragraph{Area spectrum extraction}

The spectrum image to be used for these tests will be the same for all tests in this section and may, for example, consist of float values from 0 to 1, reshaped into the size (100, 100, 10), with an energy range from $0-9 \si{\electronvolt}$.

\begin{enumerate}

\item{Extract area - square}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: Four $(x,y)$ values defining the vertices of a square (for instance, $(20, 20)$, $(20, 35)$, $(35, 35)$, $(35, 20)$). A spectrum image, as defined above for this section.

Output: An spectrum, averaged over the $(x,y)$ area defined.

How test will be performed: Using a 3D dataset, the test will request the return value of a spectrum averaged over the chosen area. No errors should be raised. Check that the correct area was used in the average (correct solution is known by manual deduction from the spectrum image).

\item{Extract area - triangle}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: A range of $(x,y)$ values defining a triangle (for instance, $(20, 20)$, $(35, 35)$, $(35, 20)$). A spectrum image, as defined above for this section.

Output: A spectrum, averaged over the $(x,y)$ values defined.

How test will be performed: Using a 3D dataset, the test will request the return value of a spectrum averaged over the chosen area. No errors should be raised. Check that the correct area was used in the average (correct solution is known by manual deduction from the spectrum image).

\item{Extract area - line}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: A range of $(x,y)$ values defining a line (for instance, $(20, 20)$, $(35, 35)$). A spectrum image, as defined above for this section.

Output: A warning that a 2D area does not exist when only two points are used to define the area.

How test will be performed: Using a 3D dataset, the test will request the return value of a spectrum averaged over the chosen area. A warning should be raised and nothing returned.

\item{Extract area - outside image}

Type: Functional, Dynamic, Unit

Initial State: Spectrum image exists in \progname{}.

Input: A range of $(x,y)$ values defining a line (for instance, $(-20, 20)$, $(35, 135)$). A spectrum image, as defined above for this section.

Output: A spectrum, averaged over the $(x,y)$ values defined, within the image dimensions. Dimensions outside the image should be rounded to the closest value within the image range (0-99).

How test will be performed: Using a 3D dataset, the test will request the return value of a spectrum averaged over the chosen area.  No errors should be raised. Check that the correct area was used in the average (correct solution is known by manual deduction from the spectrum image). The program should behave as though any image ranges outside the available range are at the closest border of the image (\textit{e.g.} -20 rounds to 0, 135 rounds to 99).

\end{enumerate}

\bibliography {TestPlan}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Code Review Checklist}

\begin{itemize}
\item Summarize in your own words what each function or unit of code does, based on inspection of the code. 
\item Is the documentation clear and readable for each function or unit of code?
\item Does the described functionality match with your written description?
\item Are all variables and functions named clearly and meaningfully?
\item Are all cases covered in IF/ELSEIF loops?
\item Do all branches in conditionals make sense (logic and resulting action is correct)?
\item Are the specifications and requirements complete and correctly implemented?
\item Is the user interface clear and easy to use?
\item Does each unit of code have a single purpose, or can it be split into multiple functions?
\item What is the expected memory usage for each function? Can it be reduced? (\textit{e.g.} are unnecessary copies of arrays being created?)
\item Are array slicing references in the correct order? (\textit{e.g.}, check correct dimension is used)
\end{itemize}

\end{document}